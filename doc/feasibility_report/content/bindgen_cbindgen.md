## C与Rust的相互调用
在进行`Rust`改写`RT-Thread`系统时，我们计划逐步替换核心组件并进行调试。在部分化Rust代码时，需要Rust模块与基于C语言的系统进行交互，我们需要进行`Rust`与`C`代码的的相互调用。

在调研Rust调用C的过程中，我们不但要考虑两种语言的特点，我们还需要考虑`RT-Thread`系统的特点，考虑其作为嵌入式系统的约束（如裸机环境、无标准库、低级内存操作等）。
### Rust调用C
在 Rust 中调用 C 语言的代码通常通过 **FFI（Foreign Function Interface）** 机制来实现。可以通过建立静态或动态链接实现 Rust 对 C 的调用，下面提供两种方式实现。
1. 使用 `extern "C"` 声明 C 函数
2. 使用 `bindgen` 自动生成绑定

#### 使用`extern "C"` 声明 C 函数
1. **文件结构：**
    ```
    .
    ├── Cargo.toml          
    ├── build.rs      
    ├── csrc     
    │   └── add.c   
    └── src
        └── main.rs 
    ```

2. **C代码准备**
    ```c
    // add.c
    int add(int a, int b) {
        return a + b;
    }
    ```
   **Rust代码**
   ```rust
    // main.rs
    extern "C" {
        fn add(a: i32, b: i32) -> i32;
    }

    fn main() {
        unsafe {
            let result = add(3, 4);
            println!("3 + 4 = {}", result);
        }
    }

    // build.rs
    fn main() {
    cc::Build::new()
        .file("csrc/add.c")
        .compile("add");
    }
    ```
    **Cargo.toml**
    ```rust
    [package]
    name = "rust_static_link"
    version = "0.1.0"
    edition = "2024"
    build = "build.rs"

    [dependencies]

    [build-dependencies]
    cc = "1.0"
    ```
3. **构建后的目录框架**
    ```
    .
    ├── build.rs                      # 用于构建 C 代码的脚本
    ├── Cargo.toml                    # Rust 项目的配置文件
    ├── csrc
    │   └── add.c                     # C 代码文件
    ├── src
    │   └── main.rs                   # Rust 主程序
    └── target
        ├── debug
        │   ├── deps
        │   │   ├── rust_static_link.exe  # Rust 编译生成的可执行文件
        │   │   ├── rust_static_link.pdb  # 调试符号文件
        │   │   └── ...
        │   ├── build
        │   │   ├──rust_static_link-e3f7be2f5fe30a4b
        │   │   ├── out
        │   │   │   ├── add.lib           # 静态链接的 C 库文件（`add` 函数）
        │   │   │   └── ...
        │   │   └── ...
        │   ├── rust_static_link.d        # 可执行文件的依赖信息
        │   ├── rust_static_link.exe  
        │   ├── rust_static_link.pdb  
        │   └── incremental              # 增量编译缓存
        └── ...            
    ```
4. **执行结果**
    ```
    $ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.04s
     Running `target\debug\rust_static_link.exe`
    3 + 4 = 7
    ```

#### 使用 `bindgen` 自动生成绑定

bindgen 工具可以手动调用（或通过 build.rs 构建脚本调用）以创建相应的 Rust 文件.
代码如下：
```c
#ifndef FOO_H
#define FOO_H

int add(int a, int b);

#endif

```
由bindgen自动生成 Rust 代码如下：
```
/* automatically generated by rust-bindgen 0.69.5 */

extern "C" {
    pub fn add(a: ::std::os::raw::c_int, b: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
```
这可以很方便的处理大量C函数的处理要求，对我们项目的构建很有帮助。

### C 调用 Rust
#### 使用静态链接调用 Rust
1. **文件结构**
   ```
    .
    ├── Makefile
    ├── main
    ├── main.c
    └── rustlib
        ├── Cargo.lock
        ├── Cargo.toml
        ├── src
        │   └── lib.rs
        └── target
            ├── CACHEDIR.TAG
            └── release
                ├── build
                ├── deps
                │   ├── librustlib-499510f3cbdd2024.a
                │   └── rustlib-499510f3cbdd2024.d
                ├── examples
                ├── incremental
                ├── librustlib.a
                └── librustlib.d
   ```
2. **代码**
   ```c
    //main.c
    #include <stdio.h>

    extern int add(int a, int b);

    int main() {
        int result = add(3, 4);
        printf("Result from Rust: %d\n", result);
        return 0;
    }

    //lib.rs
    #[unsafe(no_mangle)]
    pub extern "C" fn add(a: i32, b: i32) -> i32 {
        a + b
    }

    //cargo.toml
    [package]
    name = "rustlib"
    version = "0.1.0"
    edition = "2024"

    [dependencies]


    [lib]
    name = "rustlib"
    crate-type = ["staticlib"]

    //Makefile
    # 编译器和参数
    CC = gcc
    CFLAGS = -I.
    RUST_TARGET_DIR = rustlib/target/release
    RUST_LIB = $(RUST_TARGET_DIR)/librustlib.a

    # 默认目标
    all: build

    # 构建Rust库
    $(RUST_LIB):
        cd rustlib && cargo build --release

    # 编译并链接C程序
    build: main.c $(RUST_LIB)
        $(CC) main.c -o main $(RUST_LIB) -ldl -lpthread

    # 清理构建文件
    clean:
        cd rustlib && cargo clean
        rm -f main
   ```
3. **执行结果**
   ```
   $ make
   gcc main.c -o main rustlib/target/release/librustlib.a -ldl -lpthread
   $ ./main
   Result from Rust: 7
   ```